// AUTOGENERATED BY private/apigen
// DO NOT EDIT.

package consoleapi

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"github.com/gorilla/mux"
	"github.com/zeebo/errs"
	"go.uber.org/zap"

	"storj.io/common/uuid"
	"storj.io/storj/private/api"
	"storj.io/storj/satellite/accounting"
	"storj.io/storj/satellite/console"
)

const dateLayout = "2006-01-02T15:04:05.000Z"

var ErrProjectsAPI = errs.Class("consoleapi projects api")
var ErrApikeysAPI = errs.Class("consoleapi apikeys api")
var ErrUsersAPI = errs.Class("consoleapi users api")

type ProjectManagementService interface {
	GenCreateProject(context.Context, console.ProjectInfo) (*console.Project, api.HTTPError)
	GenUpdateProject(context.Context, uuid.UUID, console.ProjectInfo) (*console.Project, api.HTTPError)
	GenDeleteProject(context.Context, uuid.UUID) api.HTTPError
	GenGetUsersProjects(context.Context) ([]console.Project, api.HTTPError)
	GenGetSingleBucketUsageRollup(context.Context, uuid.UUID, string, time.Time, time.Time) (*accounting.BucketUsageRollup, api.HTTPError)
	GenGetBucketUsageRollups(context.Context, uuid.UUID, time.Time, time.Time) ([]accounting.BucketUsageRollup, api.HTTPError)
}

type APIKeyManagementService interface {
	GenCreateAPIKey(context.Context, console.CreateAPIKeyRequest) (*console.CreateAPIKeyResponse, api.HTTPError)
}

type UserManagementService interface {
	GenGetUser(context.Context) (*console.ResponseUser, api.HTTPError)
}

// ProjectManagementHandler is an api handler that exposes all projects related functionality.
type ProjectManagementHandler struct {
	log     *zap.Logger
	service ProjectManagementService
	auth    api.Auth
}

// APIKeyManagementHandler is an api handler that exposes all apikeys related functionality.
type APIKeyManagementHandler struct {
	log     *zap.Logger
	service APIKeyManagementService
	auth    api.Auth
}

// UserManagementHandler is an api handler that exposes all users related functionality.
type UserManagementHandler struct {
	log     *zap.Logger
	service UserManagementService
	auth    api.Auth
}

func NewProjectManagement(log *zap.Logger, service ProjectManagementService, router *mux.Router, auth api.Auth) *ProjectManagementHandler {
	handler := &ProjectManagementHandler{
		log:     log,
		service: service,
		auth:    auth,
	}

	projectsRouter := router.PathPrefix("/api/v0/projects").Subrouter()
	projectsRouter.HandleFunc("/create", handler.handleGenCreateProject).Methods("POST")
	projectsRouter.HandleFunc("/update/{id}", handler.handleGenUpdateProject).Methods("PATCH")
	projectsRouter.HandleFunc("/delete/{id}", handler.handleGenDeleteProject).Methods("DELETE")
	projectsRouter.HandleFunc("/", handler.handleGenGetUsersProjects).Methods("GET")
	projectsRouter.HandleFunc("/bucket-rollup", handler.handleGenGetSingleBucketUsageRollup).Methods("GET")
	projectsRouter.HandleFunc("/bucket-rollups", handler.handleGenGetBucketUsageRollups).Methods("GET")

	return handler
}

func NewAPIKeyManagement(log *zap.Logger, service APIKeyManagementService, router *mux.Router, auth api.Auth) *APIKeyManagementHandler {
	handler := &APIKeyManagementHandler{
		log:     log,
		service: service,
		auth:    auth,
	}

	apikeysRouter := router.PathPrefix("/api/v0/apikeys").Subrouter()
	apikeysRouter.HandleFunc("/create", handler.handleGenCreateAPIKey).Methods("POST")

	return handler
}

func NewUserManagement(log *zap.Logger, service UserManagementService, router *mux.Router, auth api.Auth) *UserManagementHandler {
	handler := &UserManagementHandler{
		log:     log,
		service: service,
		auth:    auth,
	}

	usersRouter := router.PathPrefix("/api/v0/users").Subrouter()
	usersRouter.HandleFunc("/", handler.handleGenGetUser).Methods("GET")

	return handler
}

func (h *ProjectManagementHandler) handleGenCreateProject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	projectInfo := &console.ProjectInfo{}
	if err = json.NewDecoder(r.Body).Decode(&projectInfo); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	retVal, httpErr := h.service.GenCreateProject(ctx, *projectInfo)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GenCreateProject response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *ProjectManagementHandler) handleGenUpdateProject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		h.auth.RemoveAuthCookie(w)
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	idParam, ok := mux.Vars(r)["id"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing id route param"))
		return
	}

	id, err := uuid.FromString(idParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	projectInfo := &console.ProjectInfo{}
	if err = json.NewDecoder(r.Body).Decode(&projectInfo); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	retVal, httpErr := h.service.GenUpdateProject(ctx, id, *projectInfo)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GenUpdateProject response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *ProjectManagementHandler) handleGenDeleteProject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		h.auth.RemoveAuthCookie(w)
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	idParam, ok := mux.Vars(r)["id"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing id route param"))
		return
	}

	id, err := uuid.FromString(idParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	httpErr := h.service.GenDeleteProject(ctx, id)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
	}
}

func (h *ProjectManagementHandler) handleGenGetUsersProjects(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	retVal, httpErr := h.service.GenGetUsersProjects(ctx)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GenGetUsersProjects response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *ProjectManagementHandler) handleGenGetSingleBucketUsageRollup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		h.auth.RemoveAuthCookie(w)
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	projectID, err := uuid.FromString(r.URL.Query().Get("projectID"))
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	bucket := r.URL.Query().Get("bucket")
	if bucket == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'bucket' can't be empty"))
		return
	}

	since, err := time.Parse(dateLayout, r.URL.Query().Get("since"))
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	before, err := time.Parse(dateLayout, r.URL.Query().Get("before"))
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	retVal, httpErr := h.service.GenGetSingleBucketUsageRollup(ctx, projectID, bucket, since, before)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GenGetSingleBucketUsageRollup response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *ProjectManagementHandler) handleGenGetBucketUsageRollups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		h.auth.RemoveAuthCookie(w)
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	projectID, err := uuid.FromString(r.URL.Query().Get("projectID"))
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	since, err := time.Parse(dateLayout, r.URL.Query().Get("since"))
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	before, err := time.Parse(dateLayout, r.URL.Query().Get("before"))
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	retVal, httpErr := h.service.GenGetBucketUsageRollups(ctx, projectID, since, before)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GenGetBucketUsageRollups response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}

func (h *APIKeyManagementHandler) handleGenCreateAPIKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		h.auth.RemoveAuthCookie(w)
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	apikeyInfo := &console.CreateAPIKeyRequest{}
	if err = json.NewDecoder(r.Body).Decode(&apikeyInfo); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	retVal, httpErr := h.service.GenCreateAPIKey(ctx, *apikeyInfo)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GenCreateAPIKey response", zap.Error(ErrApikeysAPI.Wrap(err)))
	}
}

func (h *UserManagementHandler) handleGenGetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		h.auth.RemoveAuthCookie(w)
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	retVal, httpErr := h.service.GenGetUser(ctx)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GenGetUser response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}
